<!-- -*- coding: utf-8 -*- -->
# サンプルプログラムのデータについて

[ 日本語 / [英語 (English)](./sample-data.md) ]

[連立方程式を解くニュートン法ライブラリ](../README.ja.md)
&gt;
サンプルプログラムのデータについて

---

本ライブラリの三種類のサンプルプログラム

* 最小二乗法を使わないサンプル
    + [sample.cc](../sample.cc)
* 最小二乗法を使ったサンプル（重み無し）
    + [sample-non_weighted.cc](../sample-non_weighted.cc)
* 最小二乗法を使ったサンプル（重み付き）
    + [sample-weighted.cc](../sample-weighted.cc)

は、いずれもGPS衛星の座標と距離からGPS受信機の位置を計算する、
というものになっています。
サンプルプログラムで使用している座標、距離、重み等は文献[1]のものを
利用させていただいております。

ここでは、文献[1]のプログラムやデータから、
座標、距離、重みを抜き出してきた方法を説明します。

## プログラムとデータ

文献[1]から「プログラムリスト：Linux版(gcc使用）」の「その3」
をダウンロードします。

* プログラムリスト：Linux版(gcc使用） その3
    + [
http://www.enri.go.jp/~fks442/K_MUSEN/3rd/3rd170626.tgz
](http://www.enri.go.jp/~fks442/K_MUSEN/3rd/3rd170626.tgz)

普通に解凍して `make` すると（警告表示は出ますが）
gcc 5.4.0 の環境でコンパイルできました。  
データファイルは「１時間データ（Linux版）」をダウンロードします。

* １時間データ（Linux版）
    + [
http://www.enri.go.jp/~fks442/K_MUSEN/data/kmusen020425_s.gps.gz
](http://www.enri.go.jp/~fks442/K_MUSEN/data/kmusen020425_s.gps.gz)

こちらも解凍し、 `make` したファイル `position` と同じディレクトリに入れて、

```
$ ./position kmusen020425_s.gps
```

とすると、実行して結果を得ることができました。  
このプログラムやデータの詳細は、文献[1]の解説記事等をご覧ください。

* 解説記事 （その３） 測位計算のはなし
    + [
http://www.enri.go.jp/~fks442/K_MUSEN/3rd/3rd070305.pdf
](http://www.enri.go.jp/~fks442/K_MUSEN/3rd/3rd070305.pdf)

ここから先は、このプログラムとデータを使って、
サンプルに必要な情報を抜き出すことにします。

## データを抜き出す

サンプルプログラムに必要な、
座標、距離、重みのデータを抜き出した方法を説明します。

### 重み無し

まずは、最初の2つサンプルプログラム、

* 最小二乗法を使わないサンプル
    + [sample.cc](../sample.cc)
* 最小二乗法を使ったサンプル（重み無し）
    + [sample-non_weighted.cc](../sample-non_weighted.cc)

向けです。

#### パッチ

文献[1]のプログラムに以下のようなパッチを当てます。
最初の hunk は、測位計算毎に

* 衛星の座標
* 測定された距離
* GPS 受信機の位置
    + GPS 受信機が出力したもの
    + プログラムで計算したもの
    + 精密に測定した本当の位置

を表示する機能を追加するものです。
座標はすべて ECEF 直交座標
（地球重心を原点にした x, y, z で表すもの、詳細は文献[1]の解説記事を参照）
で出力します。
次の hunk は測位計算を「重み無し」に変更するものです。

```diff
--- positioning.c.org	2003-07-22 19:23:35.000000000 +0900
+++ positioning.c	2017-06-24 23:30:33.304108100 +0900
@@ -86,6 +86,34 @@
 	nov_vec = blh2ecef(nov.lat, nov.lon, nov.hgt + nov.undulation);
 	pos_enu = ecef2enu(nov_vec, ori_ecef);
 
+/***********************************************/
+printf ("--- Satellite position ---\n");
+printf ("{\n");
+for ( i = 0; i < pos.nos; ++i )
+  printf ("  { %18.6f, %18.6f, %18.6f },\n",
+          pos.sx[i], pos.sy[i], pos.sz[i]);
+printf ("};\n");
+printf ("--- Observed distance ---\n");
+printf ("{\n");
+for ( i = 0; i < pos.nos; ++i )
+  printf ("  %18.6f,\n", pos.pr[i]);
+printf ("};\n");
+printf ("--- Receiver position (receiver output) ---\n");
+printf ("{\n");
+printf ("  %18.8f, %18.8f, %18.8f\n",
+        nov_vec.a[0], nov_vec.a[1], nov_vec.a[2]);
+printf ("};\n");
+printf ("--- Receiver position (calculated) ---\n");
+printf ("{\n");
+printf ("  %18.8f, %18.8f, %18.8f\n",
+        ans_vec.a[0], ans_vec.a[1], ans_vec.a[2]);
+printf ("};\n");
+printf ("--- Receiver position (accurate position) ---\n");
+printf ("{\n");
+printf ("  %18.8f, %18.8f, %18.8f\n",
+        ori_ecef.a[0], ori_ecef.a[1], ori_ecef.a[2]);
+printf ("};\n");
+/***********************************************/
 
 /*--- 計算結果の測位値(ENU)
 	printf("%10.1f %3d %13.3f %13.3f %13.3f ",svd.seconds,pos.nos,enu.a[0],enu.a[1],enu.a[2]);
@@ -159,7 +187,7 @@
 		if(rge.seconds == svd.seconds){
 			if(rge.seconds == pos.seconds){
 					inpos = copy_position();			/*--- データセットを揃える */
-					ans   = posdet(inpos, 1);			/*--- 測位演算 */
+					ans   = posdet(inpos, 0);			/*--- 測位演算 */
 					result_disp(ans, inpos, pos);	/*--- 結果の表示 */
 			}
 		}
```

※オリジナルは日本語コードが EUC-JP になっているようですので、
注意してください。

#### 実行

パッチを当てたら、`make` して再度以下のように実行します。
（かなりの分量が出力されるため、 `less` するなり、
どこかにリダイレクトするなりした方が良いと思います。）

```
$ ./position kmusen020425_s.gps
```

すると、以下のような出力が得られます。
（これは、一番最初の測位の出力を抜粋したものです。
この後にもたくさんの測位計算の結果が出力されます。）

```
--- Satellite position ---
{
  {   -11327938.990000,     9886884.330000,    21895433.227000 },
  {     4755496.711000,    19362623.328000,    18112665.323000 },
  {    -7506201.243000,    24076860.073000,     7092793.940000 },
  {   -23085789.286000,    12409399.010000,     4602891.246000 },
  {   -21893190.888000,    -2248546.668000,    14796664.928000 },
  {   -24893247.395000,     3827508.606000,    -8794926.751000 },
  {   -12971740.598000,   -10587013.898000,    21061849.442000 },
  {     7069732.127000,    22267387.067000,    12627670.276000 },
};
--- Observed distance ---
{
     20690632.972000,
     23225588.018000,
     21288081.687000,
     21187099.471000,
     21833271.739000,
     24393427.283000,
     24031767.538000,
     23630886.925000,
};
--- Receiver position (receiver output) ---
{
   -3947719.26806012,   3364403.97255818,   3699487.31995512
};
--- Receiver position (calculated) ---
{
   -3947719.36876915,   3364403.46661849,   3699487.64248845
};
--- Receiver position (accurate position) ---
{
   -3947715.67028683,   3364402.21358754,   3699479.12121749
};
  377687.0   8           0.450           0.409          -0.016
```

#### 適用

これで座標等が得られました。
先の結果は、衛星の座標と測定された距離がそれぞれ 8 つ出力されており、
この計測では 8 つの衛星が使われた、ということがわかります。

##### 最小二乗法を使わないサンプル

GPS の測位計算は未知数 4 なので、最小二乗法を使わないのであれば、
衛星の数も 4 である必要があります。
そこで、最初の 4 つのみを利用することにします。
すると、衛星の座標は最初の 4 行を抜き出して、

```c++
{
  {   -11327938.990000,     9886884.330000,    21895433.227000 },
  {     4755496.711000,    19362623.328000,    18112665.323000 },
  {    -7506201.243000,    24076860.073000,     7092793.940000 },
  {   -23085789.286000,    12409399.010000,     4602891.246000 },
};
```

の部分だけ使うことにします。
測定した距離も同様に最初の 4 行を抜き出して、

```c++
{
     20690632.972000,
     23225588.018000,
     21288081.687000,
     21187099.471000,
};
```

の部分だけを使います。
また、サンプルプログラムは、文献[1]のプログラムが計算した座標（正解）と、
サンプルプログラムが計算した座標との差分（誤差）を表示するようにしています。
そのため GPS 受信機の座標として、文献[1]のプログラムが計算した座標
（`--- Receiver position (calculated) ---` の部分）
を使います。

```c++
{
   -3947719.36876915,   3364403.46661849,   3699487.64248845
};
```

これらの座標と距離が [sample.cc](../sample.cc) に埋め込まれています。
サンプルプログラムの実行結果は以下のようになりました（抜粋）。

```
Solution: P (x y z) and delta_S:
 -3947717.825152 3364407.721345 3699485.385124 -14.272990
Error distance:
 5.057781
```

文献[1]のプログラムを重み無しに設定したものと比べて約 5 m 強の誤差がある、
ということになります。
文献[1]のプログラムは 8 衛星を使って最小二乗法で計算したものに対して、
このサンプルプログラムは 4 衛星しか使っていませんから、
この程度の誤差は出るものと思います。

##### 最小二乗法を使ったサンプル（重み無し）

次に、最小二乗法を使ったサンプルでは 8 つ全部の衛星の座標、距離を使います。
ですので、衛星の座標は、

```c++
{
  {   -11327938.990000,     9886884.330000,    21895433.227000 },
  {     4755496.711000,    19362623.328000,    18112665.323000 },
  {    -7506201.243000,    24076860.073000,     7092793.940000 },
  {   -23085789.286000,    12409399.010000,     4602891.246000 },
  {   -21893190.888000,    -2248546.668000,    14796664.928000 },
  {   -24893247.395000,     3827508.606000,    -8794926.751000 },
  {   -12971740.598000,   -10587013.898000,    21061849.442000 },
  {     7069732.127000,    22267387.067000,    12627670.276000 },
};
```

測定された距離は、

```c++
{
     20690632.972000,
     23225588.018000,
     21288081.687000,
     21187099.471000,
     21833271.739000,
     24393427.283000,
     24031767.538000,
     23630886.925000,
};
```

となります。
GPS 受信機の座標は、最小二乗法を使わなかったサンプルと同じです。
これらの座標と距離が
[sample-non_weighted.cc](../sample-non_weighted.cc)
に埋め込まれています。
サンプルプログラムの実行結果は以下のようになりました（抜粋）。

```
Solution: P (x y z) and delta_S:
 -3947719.368769 3364403.466618 3699487.642488 -15.392384
Error distance:
 0.000000
```

文献[1]のプログラムを重み無しに設定したものと比べて
（表示桁数の範囲で）誤差ゼロとなりました。
本ライブラリやサンプルプログラムは、
文献[1]とは計算式、処理等が異なりますが、
同じデータ、同じ条件で計算した場合の結果は一致した、ということになります。

### 重み付き

最後に重み付きの場合についてです。

* 最小二乗法を使ったサンプル（重み付き）
    + [sample-weighted.cc](../sample-weighted.cc)

#### パッチ

文献[1]のプログラムに以下のようなパッチを当てます。
最初の hunk は「重み無し」のときと同じです。
今回は「重み付き」ですので、
重み無しに変更する hunk はありません。
最後の hunk は重みを表示するためのものです。
文献[1]のプログラムでは、
重みはイテレーション毎に計算して使われるようになっており、
その構造のまま表示する機能だけを追加したため、
1回の測位計算で複数回（イテレーションの数）同じものが表示されてしまいます。

```diff
--- positioning.c.org	2003-07-22 19:23:35.000000000 +0900
+++ positioning.c	2017-06-24 23:35:17.423923400 +0900
@@ -86,6 +86,34 @@
 	nov_vec = blh2ecef(nov.lat, nov.lon, nov.hgt + nov.undulation);
 	pos_enu = ecef2enu(nov_vec, ori_ecef);
 
+/***********************************************/
+printf ("--- Satellite position ---\n");
+printf ("{\n");
+for ( i = 0; i < pos.nos; ++i )
+  printf ("  { %18.6f, %18.6f, %18.6f },\n",
+          pos.sx[i], pos.sy[i], pos.sz[i]);
+printf ("};\n");
+printf ("--- Observed distance ---\n");
+printf ("{\n");
+for ( i = 0; i < pos.nos; ++i )
+  printf ("  %18.6f,\n", pos.pr[i]);
+printf ("};\n");
+printf ("--- Receiver position (receiver output) ---\n");
+printf ("{\n");
+printf ("  %18.8f, %18.8f, %18.8f\n",
+        nov_vec.a[0], nov_vec.a[1], nov_vec.a[2]);
+printf ("};\n");
+printf ("--- Receiver position (calculated) ---\n");
+printf ("{\n");
+printf ("  %18.8f, %18.8f, %18.8f\n",
+        ans_vec.a[0], ans_vec.a[1], ans_vec.a[2]);
+printf ("};\n");
+printf ("--- Receiver position (accurate position) ---\n");
+printf ("{\n");
+printf ("  %18.8f, %18.8f, %18.8f\n",
+        ori_ecef.a[0], ori_ecef.a[1], ori_ecef.a[2]);
+printf ("};\n");
+/***********************************************/
 
 /*--- 計算結果の測位値(ENU)
 	printf("%10.1f %3d %13.3f %13.3f %13.3f ",svd.seconds,pos.nos,enu.a[0],enu.a[1],enu.a[2]);
--- posdet.c.org	2003-07-22 19:19:02.000000000 +0900
+++ posdet.c	2017-06-25 00:11:11.638007700 +0900
@@ -86,6 +86,13 @@
 			if(i == j) ret.a[i][j] = 1.0 / in2.rng_std[i]; 
 		}
 	}
+/***********************************************/
+printf ("--- Weight ---\n");
+printf ("{\n");
+for ( i = 0; i < size; ++i )
+  printf ("  %18.8f,\n", ret.a[i][i]);
+printf ("};\n");
+/***********************************************/
 	/* matdisp(ret); */
 	ret.err = 0;
 	return ret;
```

※オリジナルは日本語コードが EUC-JP になっているようですので、
注意してください。

#### 実行

パッチを当てたら、`make` して再度以下のように実行します。
（かなりの分量が出力されるため、 `less` するなり、
どこかにリダイレクトするなりした方が良いと思います。）

```
$ ./position kmusen020425_s.gps
```

すると、以下のような出力が得られます。
（これは、一番最初の測位の出力を抜粋したものです。
この後にもたくさんの測位計算の結果が出力されます。）

```
--- Weight ---
{
          0.34246575,
          0.41806020,
          0.44662796,
          0.33967391,
          0.33411293,
          0.29682398,
          0.30759766,
          0.31046259,
};
--- Weight ---
{
          0.34246575,
          0.41806020,
          0.44662796,
          0.33967391,
          0.33411293,
          0.29682398,
          0.30759766,
          0.31046259,
};
--- Weight ---
{
          0.34246575,
          0.41806020,
          0.44662796,
          0.33967391,
          0.33411293,
          0.29682398,
          0.30759766,
          0.31046259,
};
--- Satellite position ---
{
  {   -11327938.990000,     9886884.330000,    21895433.227000 },
  {     4755496.711000,    19362623.328000,    18112665.323000 },
  {    -7506201.243000,    24076860.073000,     7092793.940000 },
  {   -23085789.286000,    12409399.010000,     4602891.246000 },
  {   -21893190.888000,    -2248546.668000,    14796664.928000 },
  {   -24893247.395000,     3827508.606000,    -8794926.751000 },
  {   -12971740.598000,   -10587013.898000,    21061849.442000 },
  {     7069732.127000,    22267387.067000,    12627670.276000 },
};
--- Observed distance ---
{
     20690632.972000,
     23225588.018000,
     21288081.687000,
     21187099.471000,
     21833271.739000,
     24393427.283000,
     24031767.538000,
     23630886.925000,
};
--- Receiver position (receiver output) ---
{
   -3947719.26806012,   3364403.97255818,   3699487.31995512
};
--- Receiver position (calculated) ---
{
   -3947719.26542369,   3364403.97164603,   3699487.31861822
};
--- Receiver position (accurate position) ---
{
   -3947715.67028683,   3364402.21358754,   3699479.12121749
};
  377687.0   8          -0.001           0.000          -0.003
```

#### 適用

これで重み付きの場合の座標や重み等が得られました。
衛星が 8 つですので、重みも 8 つ出力されています。
また、重みは同じものが 3 回出力されていますが、
これは測位計算のイテレーションが 3 回だったことを示しています。

##### 最小二乗法を使ったサンプル（重み付き）

衛星の座標と測定された距離は、
最小二乗法を使ったサンプル（重み無し）と全く同じですので、
そのまま使います。新しく重みを追加しなければなりませんので、

```c++
{
          0.34246575,
          0.41806020,
          0.44662796,
          0.33967391,
          0.33411293,
          0.29682398,
          0.30759766,
          0.31046259,
};
```

の部分を使います。
GPS 受信機の座標は、文献[1]のプログラムも重み付きにしましたので、
重み無しとは異なっており、

```c++
{
   -3947719.26542369,   3364403.97164603,   3699487.31861822
};
```

を使います。これらの座標、距離、重みが
[sample-weighted.cc](../sample-weighted.cc)
に埋め込まれています。
サンプルプログラムの実行結果は以下のようになりました（抜粋）。

```
Solution: P (x y z) and delta_S:
 -3947719.265424 3364403.971646 3699487.318618 -15.633489
Error distance:
 0.000000
```

重み付きの場合も、
文献[1]のプログラムをと比べて（表示桁数の範囲で）誤差ゼロとなりました。

もう一度書きますが、本ライブラリやサンプルプログラムは、
文献[1]とは計算式、処理等が異なります。
それでも、同じデータ、同じ条件で計算した場合の結果は一致した、
ということになります。

## 参考文献

[1]
福島荘之介.
理解するためのGPS測位計算プログラム入門.
[
http://www.enri.go.jp/~fks442/K_MUSEN/
](http://www.enri.go.jp/~fks442/K_MUSEN/).

## License

Copyright (C) 2017 Masamichi Hosoda. All rights reserved.

License: BSD-2-Clause

[LICENSE](../LICENSE) をご覧ください。
